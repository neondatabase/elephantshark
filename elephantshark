#!/usr/bin/env ruby

# Copyright 2025 - 2026 Databricks, Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require "optparse"
require "openssl"
require "securerandom" # for cert generation
require "net/imap" # for SASL/SCRAM auth
require "digest" # for MD5 auth

Thread.abort_on_exception = true
Thread.report_on_exception = false

SCRIPT_NAME = "Elephantshark" # note: name must be valid as a certificate CN
SCRIPT_VERS = '0.2.2'
SCRIPT_DESC = "Postgres network traffic monitor"
SCRIPT_INFO = "https://github.com/neondatabase/elephantshark ++ Copyright 2025 - 2026 Databricks, Inc. ++ License: Apache 2.0"

options = { # set defaults
  target: nil,
  delete_host_suffix: ".local.neon.build",
  listen_ip: "127.0.0.1",
  listen_port: 5432,
  connect_port: 5432,
  ssl_negotiation: "mimic",
  sslmode: "prefer",
  sslrootcert: nil,
  force_password: false,
  redact_passwords: false,
  send_chunks: "whole",
  ssl_cert: nil,
  ssl_key: nil,
  cert_sig: "rsa",
  deny_ssl: false,
  log_certs: false,
  log_proxied: "annotated",
  client_sslkeylogfile: nil,
  server_sslkeylogfile: nil,
  bw: nil,
  allow_self_loop: false,
  quit_on_hangup: false,
  channel_binding: "prefer",
}

OptionParser.new do |opts|
  opts.version = SCRIPT_VERS
  opts.banner = "#{SCRIPT_NAME} v#{SCRIPT_VERS}, #{SCRIPT_DESC}\n#{SCRIPT_INFO}\n\nUsage:\nelephantshark [options]\n\n--client-... options affect the connection from the client to Elephantshark\n--server-... options affect the onward connection from Elephantshark to the server\n\n"
  opts.on("--server-host a.b.cd",
          "Use a fixed Postgres server hostname (default: via SNI, or 'localhost')") { |v| options[:target] = v }
  opts.on("--server-delete-suffix .b.cd",
          "Delete a suffix from server hostname provided by client (default: #{options[:delete_host_suffix]})") { |v| options[:delete_host_suffix] = v }
  opts.on("--client-listen-ip ::1|0.0.0.0|etc.",
          "IP on which to listen for client connection (default: #{options[:listen_ip]})") { |v| options[:listen_ip] = v }
  opts.on("--client-listen-port nnnn", /\d{1,5}/,
          "Port on which to listen for client connection (default: #{options[:listen_port]})") { |v| options[:listen_port] = v.to_i }
  opts.on("--server-connect-port nnnn", /\d{1,5}/,
          "Port on which to connect to server (default: #{options[:connect_port]})") { |v| options[:connect_port] = v.to_i }
  opts.on("--server-sslmode disable|prefer|require|verify-ca|verify-full", ['disable', 'prefer', 'require', 'verify-ca', 'verify-full'],
          "SSL mode for connection to server (default: #{options[:sslmode]})") { |v| options[:sslmode] = v }
  opts.on("--server-sslrootcert system|/path/to/cert",
          "Root/CA certificate for connection to server (default: #{options[:sslrootcert] || 'none'})") { |v| options[:sslrootcert] = v }
  opts.on("--server-sslnegotiation mimic|direct|postgres",
          "SSL negotiation style: mimic client, direct or traditional Postgres (default: #{options[:ssl_negotiation]})") { |v| options[:ssl_negotiation] = v }
  opts.on("--[no-]override-auth",
          "Require password auth from client, do SASL/MD5/password auth with server (default: #{options[:force_password]})") { |v| options[:force_password] = v }
  opts.on("--server-channel-binding disable|prefer|require", ['disable', 'prefer', 'require'],
          "Channel binding policy for SASL connection to server with --override-auth (default: #{options[:channel_binding]})") { |v| options[:channel_binding] = v }
  opts.on("--[no-]redact-passwords",
          "Redact password messages in logs (default: #{options[:redact_passwords]})") { |v| options[:redact_passwords] = v }
  opts.on("--send-chunking whole|byte", ["whole", "byte"],
          "Chunk size for sending Postgres data (default: #{options[:send_chunks]})") { |v| options[:send_chunks] = v }
  opts.on("--client-ssl-cert /path/to/cert",
          "TLS certificate for connection with client (default: generated, self-signed)") { |v| options[:ssl_cert] = v }
  opts.on("--client-ssl-key /path/to/key",
          "TLS key for connection with client (default: generated)") { |v| options[:ssl_key] = v }
  opts.on("--client-cert-sig rsa|ecdsa", ["rsa", "ecdsa"],
          "Specify RSA or ECDSA signature for generated certificate (default: #{options[:cert_sig]})") { |v| options[:cert_sig] = v}
  opts.on("--[no-]client-deny-ssl",
          "Tell client that SSL is not supported (default: #{options[:deny_ssl]})") { |v| options[:deny_ssl] = v }
  opts.on("--[no-]log-certs",
          "Log TLS certificates (default: #{options[:log_certs]})") { |v| options[:log_certs] = v }
  opts.on("--log-forwarded none|raw|annotated", ["none", "raw", "annotated"],
          "Whether and how to log forwarded traffic (default: #{options[:log_proxied]})") { |v| options[:log_proxied] = v }
  opts.on("--[no-]quit-on-hangup",
          "Exit when first client or server disconnects (default: #{options[:quit_on_hangup]})") { |v| options[:quit_on_hangup] = v }
  opts.on("--client-sslkeylogfile /path/to/log",
          "Where to append client traffic TLS decryption data (default: nowhere)") { |v| options[:client_sslkeylogfile] = v }
  opts.on("--server-sslkeylogfile /path/to/log",
          "Where to append server traffic TLS decryption data (default: nowhere)") { |v| options[:server_sslkeylogfile] = v }
  opts.on("--[no-]allow-self-loop", "Allow listen and connect on the same address + port (default: #{options[:allow_self_loop]})") { |v| options[:allow_self_loop] = v }
  opts.on("--[no-]bw", "Force monochrome output even to TTY (default: automatic)") { |v| options[:bw] = v }
end.parse!

options[:sslmode] = 'verify-full' if options[:sslrootcert] == 'system'  # matches libpq behaviour

ANNOTATE = options[:log_proxied] == "annotated"
REDACT = options[:redact_passwords]
BYTE_WRITE = options[:send_chunks] == "byte"
COLOURFUL = options[:bw].nil? ? STDOUT.tty? : !options[:bw]

# Ruby stdlib compatibility checks

has_sasl = Net::IMAP.const_defined?(:SASL) && Net::IMAP::SASL.const_defined?(:ScramSHA256Authenticator)
if options[:force_password] && !has_sasl
  puts "Missing Net::IMAP::SASL::ScramSHA256Authenticator, so --override-auth will not support SCRAM. Please use Ruby 3.3 or higher."
  # we'll exit later if SCRAM is requested by server
end

if options[:cert_sig] == "ecdsa" && !OpenSSL::PKey::EC.method_defined?(:public_to_pem)
  puts "Missing OpenSSL::PKey::EC#public_to_pem, so --client-cert-sig ecdsa is not supported. Please use Ruby 3.1 or higher."
  exit 1
end

# misc utils

def bin_str(str) str.force_encoding("ASCII-8BIT") end
def hex_inspect(bytes) '"' + bytes.unpack1("H*").scan(/../).map { |x| "\\x#{x}" }.join + '"' end
def t_now() Process.clock_gettime(Process::CLOCK_MONOTONIC) end
def tls_summary(sock) "#{sock.ssl_version}/#{sock.cipher.first}" end

# colour

module Colour
  S2C = "35"
  C2S = "36"
  NOTE = "33"
  CONN = "34"
  LEN = "34"
end

def colour(c, s) COLOURFUL ? "\033[#{c}m#{s}\033[0m": s end

def annotate(*args)
  args.each_slice(2)
      .map { |s, annot| "#{s}#{ANNOTATE ? colour(Colour::NOTE, " = #{annot}") : ""}" }
      .join(' ')
end

def server_to_client(s) "#{colour(Colour::S2C, "server -> client:")} #{s}" end
def server_to_script(s) "#{colour(Colour::S2C, "server -> script:")} #{s}" end
def script_to_client(s) "#{colour(Colour::S2C, "script -> client:")} #{s}" end
def client_to_server(s) "#{colour(Colour::C2S, "client -> server:")} #{s}" end
def client_to_script(s) "#{colour(Colour::C2S, "client -> script:")} #{s}" end
def script_to_server(s) "#{colour(Colour::C2S, "script -> server:")} #{s}" end

# Postgres message parsing/annotation

class PgMessage
  @@prev_auth_type = nil # lets us better interpret some auth messages

  def initialize(msg, source)
    @msg = msg
    @source = source # :server, :client, :startup or nil
    @i = 0
  end

  def text_or_binary(v) v == 0 ? "text" : v == 1 ? "binary" : "unknown" end

  # methods to read from @msg: each returns [value, representation]

  def int8
    byte = @msg[@i...@i += 1]
    [byte.unpack1("C"), hex_inspect(byte)]
  end

  def int16
    bytes = @msg[@i...@i += 2]
    [bytes.unpack1("s>"), hex_inspect(bytes)]
  end

  def int32
    bytes = @msg[@i...@i += 4]
    [bytes.unpack1("l>"), hex_inspect(bytes)]
  end

  def cstr
    value = @msg[@i..].unpack1("Z*")
    bytes = @msg[@i...@i += value.length + 1] # +1 for the null terminator
    [value, bytes.inspect]
  end

  def str(len)
    bytes = @msg[@i...@i += len]
    [bytes, bytes.inspect]
  end

  def bytes(len)
    bytes = @msg[@i...@i += len]
    [bytes, hex_inspect(bytes)]
  end

  def char
    str(1)
  end

  # annotation

  def inspect
    unless ANNOTATE
      return (REDACT && @msg[0] == "p") ? "[password message redacted]" : @msg.inspect
    end

    s = ""
    if @source == :startup # also CancelRequest
      lenv, lenr, versionmajv, versionmajr, versionminv, versionminr = int32 + int16 + int16
      if versionmajv == 1234 && versionminv == 5678
        s += annotate(lenr, "#{lenv} bytes of CancelRequest message", versionmajr, "cancel code: #{versionmajv}", versionminr, "cancel code: #{versionminv}")
        processidv, processidr = int32
        _, secretkeyr = bytes(lenv - 12) # 12 bytes = skipping the 3 int32s we already read
        s += "\n" + annotate(processidr, "target backend process ID: #{processidv}")
        s += "\n" + annotate(secretkeyr, "target backend secret key")

      else
        s += annotate(lenr, "#{lenv} bytes of startup message", versionmajr, "protocol major version #{versionmajv}", versionminr, "protocol minor version #{versionminv}")
        loop do
          keyv, keyr, = cstr
          if keyv.empty?
            s += "\n" + annotate(keyr, "end")
            break
          end
          _, valuer = cstr
          s += "\n" + annotate(keyr, "key", valuer, "value")
        end
      end

    else
      type_value, type_repr = char
      lenv, lenr = int32

      type_name = if @source == :server
        case type_value # server messages
        when "1"; "ParseComplete"
        when "2"; "BindComplete"
        when "3"; "CloseComplete"

        when "A"
          _, pidr = int32
          _, channelr = cstr
          _, payloadr = cstr
          s += annotate(pidr, "process ID", channelr, "channel name", payloadr, "payload")
          "NotificationResponse"

        when "C"
          _, tagr = cstr
          s += annotate(tagr, "command tag")
          "CommandComplete"

        when "D"
          colcountv, colcountr = int16
          s += annotate(colcountr, "#{colcountv} columns follow")
          colcountv.times do
            s += "\n"
            collenv, collenr = int32
            if collenv == -1
              s += annotate(collenr, "null column value")
            else
              _, colvaluer = str(collenv)
              s += annotate(collenr, "#{collenv} bytes", colvaluer, "column value")
            end
          end
          "DataRow"

        when "E"
          loop do
            s += "\n"
            errfieldv, errfieldr = char
            if errfieldv == bin_str("\x00")
              s += annotate(errfieldr, "end")
              break
            end
            err_field_name = {
              S: "severity",
              V: "unlocalized severity",
              C: "SQLSTATE code",
              M: "message",
              D: "detail",
              H: "hint",
              P: "position",
              p: "internal position",
              q: "internal query",
              W: "where",
              s: "schema",
              t: "table",
              c: "column",
              d: "data type",
              n: "constraint",
              F: "file",
              L: "line",
              R: "routine"
            }[errfieldv.to_sym]
            _, valuer = cstr
            s += annotate(errfieldr, "#{err_field_name}", valuer, "value")
          end
          "ErrorResponse"

        when "G", "H", "W"
          formatv, formatr, colcountv, colcountr = int8 + int16
          s += annotate(formatr, "copy format: #{text_or_binary(formatv)}", colcountr, "#{colcountv} column formats follow")
          colcountv.times do
            colformatv, colformatr = int16
            s += ' ' + annotate(colformatr, "column format: #{text_or_binary(colformatv)}")
          end
          { G: "CopyInResponse", H: "CopyOutResponse", W: "CopyBothResponse" }[type_value.to_sym]

        when "I"; "EmptyQueryResponse"

        when "K"
          pidv, pidr = int32
          s += "\n" + annotate(pidr, "process ID #{pidv}")
          _, secretkeyr = bytes(lenv - 8)
          s += "\n" + annotate(secretkeyr, "secret key")
          "BackendKeyData"

        when "N"; "NoticeResponse"

        when "R"
          authtypev, authtyper = int32
          @@prev_auth_type = authtypev
          auth_msg_name = case authtypev
          when 0; "AuthenticationOk"
          when 2; "AuthenticationKerberosV5"
          when 3; "AuthenticationCleartextPassword"
          when 7; "AuthenticationGSS"
          when 8; "AuthenticationGSSContinue"
          when 9; "AuthenticationSSPI"

          when 5
            _, saltr = bytes(4)
            s += ' ' + annotate(saltr, "MD5 salt")
            "AuthenticationMD5Password"

          when 10
            begin
              s += "\n"
              mechv, mechr = cstr
              s += annotate(mechr, mechv.empty? ? "end" : "SASL mechanism")
            end until mechv.empty?
            "AuthenticationSASL"

          when 11
            _, scramdatar = str(lenv - 8)
            s += "\n" + annotate(scramdatar, "SCRAM server-first-message")
            "AuthenticationSASLContinue"

          when 12
            _, scramdatar = str(lenv - 8)
            s += "\n" + annotate(scramdatar, "SCRAM server-final-message")
            "AuthenticationSASLFinal"

          else
            "unknown auth message type"
          end
          s = annotate(authtyper, auth_msg_name) + s
          "Authentication"

        when "S"
          _, keyr, _, valuer = cstr + cstr
          s += annotate(keyr, "key", valuer, "value")
          "ParameterStatus"

        when "T"
          colcountv, colcountr = int16
          s += annotate(colcountr, "#{colcountv} columns follow")
          colcountv.times do
            _, namer = cstr
            taboidv, taboidr, tabattrnumv, tabattrnumr = int32 + int16
            s += "\n" + annotate(
              namer, "column name",
              taboidr, "table OID: #{taboidv}",
              tabattrnumr, "table attrib no: #{tabattrnumv}"
            )
            typoidv, typoidr, typlenv, typlenr, typmodv, typmodr = int32 + int16 + int32
            formatv, formatr = int16
            s += "\n" + annotate(
              typoidr, "type OID: #{typoidv}",
              typlenr, "type length: #{typlenv}",
              typmodr, "type modifier: #{typmodv}",
              formatr, "format: #{text_or_binary(formatv)}"
            )
          end
          "RowDescription"

        when "V"
          valuelenv, valuelenr = int32
          if valuelenv == -1
            s += annotate(valuelenr, "null value")
          else
            s += annotate(valuelenr, "#{valuelenv} bytes follow")
            _, valuer = str(valuelenv)
            s += annotate(valuer, "value")
          end
          "FunctionCallResponse"

        when "Z"
          statusv, statusr = char
          status = { I: "idle", T: "in transaction block", E: "in failed transaction block" }[statusv.to_sym] || "unknown status"
          s += annotate(statusr, status)
          "ReadyForQuery"

        when "c"; "CopyDone"
        when "d"; "CopyData"
        when "n"; "NoData"
        when "s"; "PortalSuspended"

        when "t"
          paramcountv, paramcountr = int16
          s += annotate(paramcountr, "number of parameters")
          paramcountv.times do
            paramoidv, paramoidr = int32
            s += annotate(paramoidr, "parameter type OID: #{paramoidv}")
          end
          "ParameterDescription"

        when "v"
          protov, protor = int32
          s += annotate(protor, "newest minor protocol version supported: #{protov}")
          optioncountv, optioncountr = int32
          s += annotate(optioncountr, "number of unrecognised protocol options: #{optioncountv}")
          optioncountv.times do
            _, optionr = cstr
            s += "\n" + annotate(optionr, "unrecognised option")
          end
          "NegotiateProtocolVersion"

        else; "unknown server message"
        end

      elsif @source == :client
        case type_value
        when "B"
          _, portalr, _, statementr = cstr + cstr
          s += annotate(portalr, "destination portal", statementr, "source prepared statement")
          code_count, r = int16
          s += "\n" + annotate(r, "#{code_count} parameter format codes follow")
          code_count.times do
            v, r = int16
            s += annotate(r, "format: #{text_or_binary(v)}")
          end
          paramcountv, paramcountr = int16
          s += "\n" + annotate(paramcountr, "#{paramcountv} parameter values follow")
          paramcountv.times do
            paramlenv, paramlenr = int32
            if paramlenv == -1
              s += annotate(paramlenr, "null")
            else
              s += annotate(paramlenr, "#{paramlenv} bytes follow")
              _, paramr = str(paramlenv)
              s += annotate(paramr, "parameter value")
            end
          end
          resultcountv, resultcountr = int16
          s += "\n" + annotate(resultcountr, "#{resultcountv} result format codes follow")
          resultcountv.times do
            formatv, formatr = int16
            s += annotate(formatr, "format: #{text_or_binary(formatv)}")
          end
          "Bind"

        when "C", "D"
          thingtypev, thingtyper, _, thingnamer = char + cstr
          thingtype = thingtypev == "S" ? "prepared statement" : thingtypev == "P" ? "portal" : "unknown"
          s += annotate(thingtyper, thingtype, thingnamer, "name of #{thingtype}")
          { C: "Close", D: "Describe" }[type_value.to_sym]

        when "E"
          _, pnr, maxv, maxr = cstr + int32
          s += annotate(pnr, "portal name", maxr, "max rows: #{maxv}" + (maxv == 0 ? " = no limit" : ""))
          "Execute"

        when "F"
          fnoidv, fnoidr = int32
          s += annotate(fnoidr, "function OID: #{fnoidv}")
          formatcountv, formatcountr = int16
          s += "\n" + annotate(formatcountr, "#{formatcountv} format codes follow")
          formatcountv.times do
            formatv, formatr = int16
            s += annotate(formatr, "format: #{text_or_binary(formatv)}")
          end
          argscountv, argscountr = int16
          s += "\n" + annotate(argscountr, "#{argscountv} arguments follow")
          argscountv.times do
            arglenv, arglenr = int32
            _, argvalr = str(arglenv)
            s += annotate(arglenr, "#{arglenv} bytes", argvalr, "argument")
          end
          formatv, formatr = int16
          s += "\n" + annotate(formatr, "result format: #{text_or_binary(formatv)}")
          "FunctionCall"

        when "H"; "Flush"

        when "P"
          _, dr, _, qr = cstr + cstr
          s += annotate(dr, "destination prepared statement", qr, "SQL query")
          pdt_count, r = int16
          s += annotate(r, "#{pdt_count} parameter data types follow")
          pdt_count.times do
            v, r = int32
            s += annotate(r, "parameter type OID: #{v}")
          end
          "Parse"

        when "Q"
          _, queryr = cstr
          s += annotate(queryr, "query")
          "Query"

        when "S"; "Sync"
        when "X"; "Terminate"
        when "c"; "CopyDone"
        when "d"; "CopyData"

        when "f"
          _, errmsgr = cstr
          s += annotate(errmsgr, "error message")
          "CopyFail"

        when "p"
          # p can mean various things depending on context, so we need to check the last message sent the other way
          case @@prev_auth_type
          when 3 # AuthenticationCleartextPassword
            _, pwdr = cstr
            s += annotate(REDACT ? "[redacted]" : pwdr, "password")
            "PasswordMessage (cleartext)"

          when 5 # AuthenticationMD5Password
            _, md5r = cstr
            s += annotate(REDACT ? "[redacted]" : md5r, "'md5' + md5(md5(pwd + user) + salt)")
            "PasswordMessage (MD5)"

          when 10 # AuthenticationSASL
            _, mechr  = cstr
            s += "\n" + annotate(mechr, "selected mechanism")
            scramlenv, scramlenr = int32
            s += "\n" + annotate(scramlenr, "#{scramlenv} bytes follow")
            _, scramdata = str(scramlenv)
            s += "\n" + annotate(scramdata, "SCRAM client-first-message")
            "SASLInitialResponse"

          when 11 # AuthenticationSASLContinue
            _, scramdata = str(lenv - 4)
            s += "\n" + annotate(scramdata, "SCRAM client-final-message")
            "SASLResponse"

          else
            "PasswordMessage/SASLInitialResponse/SASLResponse/GSSResponse"
          end

        else
          "unknown client message"
        end

      else
        raise "unknown message source #{@source}"
      end

      s = annotate(type_repr, type_name, lenr, "#{lenv} bytes") + (s[0] == "\n" ? "" : " ") + s # prefix the message name and length
    end

    s += "\n" + annotate(@msg[@i..].inspect, "data") if @msg.length > @i # log any so-far unparsed data
    s
  end
end

# Postgres writes

def pg_msg(type, msg)
  bin_str(type + [msg.length + 4].pack("N") + msg)
end

def pg_send(sock, rawmsgs, source = nil)
  rawmsgs.each { |msg| yield PgMessage.new(msg, source).inspect } if block_given?
  bytes = rawmsgs.join
  if BYTE_WRITE
    bytes.each_char { |char| sock.write(char) }
  else
    sock.write(bytes)
  end
  bytes.length
end

# Postgres reads

class BufferingConnection
  attr_reader :buffer

  def initialize(sock)
    super()
    @sock = sock
    @buffer = bin_str("")
  end

  def blocking_buffer_to(length)
    if @buffer.length < length
      bytes = @sock.read(length - @buffer.length)
      return nil if bytes.nil?
      @buffer += bytes
    end
    true
  end

  def nonblocking_buffer_to(length)
    return true if @buffer.length >= length
    begin
      bytes = @sock.read_nonblock((1 << 31) - 1) # maximum possible read
      @buffer += bytes
      @buffer.length >= length # return true or false
    rescue OpenSSL::SSL::SSLErrorWaitReadable, OpenSSL::SSL::SSLErrorWaitWritable, IO::EAGAINWaitReadable
      false
    rescue OpenSSL::SSL::SSLError, EOFError
      nil
    end
  end

  def buffer_to(length, blocking)
    blocking ? blocking_buffer_to(length) : nonblocking_buffer_to(length)
  end
end

class PGConnection < BufferingConnection
  def initialize(sock, source)
    super(sock)
    @source = source # :server, :client, :startup or nil
  end

  def next_message(blocking = true)
    # if blocking: returns message, or nil at EOF
    # if non-blocking: returns message, or false if none available, or nil at EOF
    result = buffer_to(5, blocking) or return result
    length_incl = @buffer[1...5].unpack1("N")
    result = buffer_to(1 + length_incl, blocking) or return result # 1 + not 5 +, because len is inclusive
    msg = @buffer.slice!(0..length_incl) # inclusive length accounts for the first (message type) byte
    yield PgMessage.new(msg, @source).inspect if block_given?
    msg
  end

  def available_messages(&blk)
    messages = []
    while true do
      nm = next_message(messages.empty?, &blk)
      return nil if nm.nil? && messages.empty?
      break unless nm
      messages << nm
    end
    messages
  end
end

# tls-server-end-point channel-binding support for ScramSHA256Authenticator net/imap

if has_sasl
  class ScramSHA256Authenticator < Net::IMAP::SASL::ScramSHA256Authenticator
    def initialize(*args, **options)
      super(*args, **options)
      @ssl_cert = options[:ssl_cert]
    end

    def gs2_cb_flag
      @ssl_cert.nil? ? "n" : "y" # y => would have supported -PLUS if server had offered it
    end
  end

  class ScramSHA256PlusAuthenticator < ScramSHA256Authenticator
    def gs2_cb_flag
      "p=tls-server-end-point"
    end

    def cbind_input
      cert_algo_raw = @ssl_cert.signature_algorithm
      cert_algo = OpenSSL::Digest.new(cert_algo_raw).name # standardize e.g. sha256WithRSAEncryption -> SHA256
      sasl_algo = cert_algo == "MD5" || cert_algo == "SHA1" ? "SHA256" : cert_algo
      hash = OpenSSL::Digest.digest(sasl_algo, @ssl_cert.to_der)
      "#{gs2_header}#{hash}"
    end
  end
end

# certificate generation

def make_key_and_cert(subject, sig)
  key = sig == "ecdsa" ? OpenSSL::PKey::EC.generate("prime256v1") : OpenSSL::PKey::RSA.new(2048)
  public_key = sig == "ecdsa" ? OpenSSL::PKey::EC.new(key.public_to_pem) : key.public_key

  cert = OpenSSL::X509::Certificate.new
  cert.public_key = public_key
  cert.not_before = Time.now - 24 * 3600 # 24 hours ago
  cert.not_after = Time.now + 48 * 3600 # 48 hours ahead

  # for sslmode=require, the server cert can be _extremely_ bare bones: the following are not required
  cert.version = 2 # cf. RFC 5280 - to make it a "v3" certificate
  cert.serial = (1 + SecureRandom.random_number((1 << 128) - 1)).to_bn # not zero
  cert.issuer = cert.subject = OpenSSL::X509::Name.parse(subject)

  cert.sign(key, "SHA256")
  [key, cert]
end

# infinite loop detection

def normalize_host(host)
  # fancier checks and lookups are possible, but this should catch many issues
  host = host.downcase.strip 
  case host
  when '', 'localhost', 'localhost.localdomain', '127.0.0.1', '0.0.0.0', /^[:0]+1$/, /^[:0]+$/
    :local
  else
    host
  end
end

def connecting_to_self?(target_host, target_port, listen_host, listen_port)
  target_port == listen_port && normalize_host(target_host) == normalize_host(listen_host)
end

# main loop

ssl_request = [8, (1234 << 16) + 5679].pack("NN")
server = TCPServer.new(options[:listen_ip], options[:listen_port])
conn_num = 0

def print_conn_num(conn_num)
  print(colour(Colour::CONN, "\##{conn_num}  "))
end

loop do
  conn_num += 1
  print_conn_num(conn_num)
  puts "listening on #{options[:listen_ip]} port #{options[:listen_port]} ..."

  conn_thread = Thread.new(server.accept, conn_num) do |client_sock, conn_num|
    begin
      # make sure these names are defined in the ensure block
      server_sock = client_to_server_thread = server_to_client_thread = nil

      print_conn_num(conn_num)
      puts "connected at t0 = #{Time.now}"

      cnputs = lambda do |*args|
        args.each_with_index do |arg, i|
          arg.split("\n").each_with_index do |line, j|
            print_conn_num(conn_num)
            print("  ") unless i == 0 && j == 0
            puts(line)
          end
        end
      end

      early_exit = lambda do |msg|
        cnputs.("disconnected #{msg}")
        Thread.exit
      end

      target_via_sni = nil
      t0 = t_now

      # client SSL context

      client_ctx = OpenSSL::SSL::SSLContext.new
      client_ctx.options |= OpenSSL::SSL::OP_IGNORE_UNEXPECTED_EOF if OpenSSL::SSL.const_defined?(:OP_IGNORE_UNEXPECTED_EOF)

      if options[:ssl_key] && options[:ssl_cert]
        client_ctx.key = OpenSSL::PKey::RSA.new(File.open(options[:ssl_key]))
        client_ctx.cert = OpenSSL::X509::Certificate.new(File.open(options[:ssl_cert]))
      else
        raise "must specify both or neither of --client-ssl-cert and --client-ssl-key" if options[:ssl_key] || options[:ssl_cert]
        client_ctx.key, client_ctx.cert = make_key_and_cert("CN=#{SCRIPT_NAME}", options[:cert_sig])
      end

      client_ctx.servername_cb = lambda do |sniData|
        sni_sock, sni_name = sniData
        target_via_sni = sni_name
        sni_sock.context
      end

      client_ctx.alpn_select_cb = lambda do |protocols|
        # alpn is required in response for direct SSL connections
        raise "unexpected ALPN protocols: #{protocols.inspect}" unless protocols == ["postgresql"]
        protocols.first
      end

      unless options[:client_sslkeylogfile].nil?
        client_ctx.keylog_cb = proc do |_sock, line|
          File.open(options[:client_sslkeylogfile], "a") { |f| f.puts(line) }
        end
      end

      # SSL negotiations

      client_direct_ssl = nil

      first_byte = client_sock.recv(1, Socket::MSG_PEEK)
      early_exit.("with no data received") if first_byte.nil?

      if first_byte == bin_str("\x16") # start of a TLS handshake record
        client_direct_ssl = true
        client_sock = OpenSSL::SSL::SSLSocket.new(client_sock, client_ctx).accept # begin handshake
        cnputs.("direct #{tls_summary(client_sock)} connection established with client", "  server name via SNI: #{target_via_sni}")

        first_eight = client_sock.read(8)

      else
        # not direct SSL, so we may or may not begin with an 8-byte SSLRequest
        first_eight = client_sock.read(8)

        if first_eight == ssl_request
          client_direct_ssl = false
          cnputs.(client_to_script(annotate(hex_inspect(first_eight), "SSLRequest")))

          if options[:deny_ssl]
            client_sock.write("N")
            cnputs.(script_to_client(annotate("N".inspect, "SSL not supported")))

          else
            client_sock.write("S")
            cnputs.(script_to_client(annotate("S".inspect, "SSL supported")))

            client_sock = OpenSSL::SSL::SSLSocket.new(client_sock, client_ctx).accept # begin handshake
            cnputs.("#{tls_summary(client_sock)} connection established with client", "server name via SNI: #{target_via_sni}")
          end

          first_eight = client_sock.read(8)

        else
          cnputs.("no SSLRequest: continuing in plaintext")
        end
      end

      cnputs.("client TLS cert", client_sock.cert.to_text, client_sock.cert.to_pem) if options[:log_certs] && client_sock.respond_to?(:cert)

      early_exit.("reading first eight bytes") if first_eight.nil? || first_eight.length < 8 # start again if disconnected

      # connection startup + auth

      len = first_eight[0..3].unpack1("N")

      startup_msg = client_sock.read(len - 8)
      full_startup = first_eight + startup_msg
      cnputs.(client_to_script(PgMessage.new(full_startup, :startup).inspect))

      username = nil
      startup_msg.split("\x00").each_slice(2) { |x| username = x[1] if x[0] == "user" }

      server_name = options[:target] || (target_via_sni ? target_via_sni.chomp(options[:delete_host_suffix]) : "localhost")
      cnputs.("connecting to Postgres server: #{server_name}")

      if connecting_to_self?(server_name, options[:connect_port], options[:listen_ip], options[:listen_port]) && !options[:allow_self_loop]
        early_exit.("to avoid possible infinite loop: host + port for listen and connect are the same (disable this check with --allow-self-loop)")
      end
      server_sock = TCPSocket.new(server_name, options[:connect_port])

      if options[:sslmode] != 'disable'
        server_direct_ssl = options[:ssl_negotiation] == "direct" || (options[:ssl_negotiation] == "mimic" && client_direct_ssl)
        server_speaks_ssl = nil

        unless server_direct_ssl
          server_sock.write(ssl_request)
          cnputs.(script_to_server(annotate(hex_inspect(ssl_request), "SSLRequest")))

          server_speaks_ssl = server_sock.read(1)
          cnputs.(server_to_script(annotate(server_speaks_ssl.inspect, server_speaks_ssl == "S" ? "SSL supported" : "SSL not supported")))
        end

        if server_speaks_ssl == "S" || server_direct_ssl
          server_ctx = OpenSSL::SSL::SSLContext.new
          server_ctx.options |= OpenSSL::SSL::OP_IGNORE_UNEXPECTED_EOF if OpenSSL::SSL.const_defined?(:OP_IGNORE_UNEXPECTED_EOF)
          server_ctx.alpn_protocols = ['postgresql']  # required for direct connections

          server_ctx.verify_mode = options[:sslmode].start_with?('verify') ? OpenSSL::SSL::VERIFY_PEER : OpenSSL::SSL::VERIFY_NONE
          server_ctx.verify_hostname = options[:sslmode] == 'verify-full'

          server_ctx.cert_store = OpenSSL::X509::Store.new
          unless options[:sslrootcert].nil?
            if options[:sslrootcert] == 'system'
              server_ctx.cert_store.set_default_paths
            elsif File.directory?(options[:sslrootcert])
              server_ctx.cert_store.add_path(options[:sslrootcert])
            else
              server_ctx.cert_store.add_file(options[:sslrootcert])
            end
          end

          unless options[:server_sslkeylogfile].nil?
            server_ctx.keylog_cb = proc do |_, line|
              File.open(options[:server_sslkeylogfile], "a") { |f| f.puts(line) }
            end
          end

          server_sock = OpenSSL::SSL::SSLSocket.new(server_sock, server_ctx)
          server_sock.hostname = server_name
          server_sock.connect

          cnputs.("#{server_direct_ssl ? "direct " : ""}#{tls_summary(server_sock)} connection established with server")
          cnputs.("server TLS cert", server_sock.peer_cert.to_text, server_sock.peer_cert.to_pem) if options[:log_certs] && server_sock.respond_to?(:peer_cert)

        elsif server_speaks_ssl == "N"
          raise 'server does not support SSL' if options[:sslmode] != 'prefer'
          cnputs.("continuing without encryption")

        else
          raise "expected S or N in response to SSLRequest, but got #{server_speaks_ssl.inspect}"
        end
      end

      cnputs.("forwarding client startup message to server")
      server_sock.write(full_startup)
      cnputs.(script_to_server(PgMessage.new(full_startup, :startup).inspect))

      server_reader = PGConnection.new(server_sock, :server)
      client_reader = PGConnection.new(client_sock, :client)

      # authentication override, if requested

      if options[:force_password] # request password from client, and use it to do either password or SCRAM auth with server
        cnputs.("now overriding authentication")
        auth_msg = server_reader.next_message { |str| cnputs.(server_to_script(str)) }
        early_exit.("awaiting auth message") if auth_msg.nil?
        raise "expected auth message" unless auth_msg[0] == "R"

        auth_type = auth_msg[5..8].unpack1("N")
        if auth_type == 0
          cnputs.("forwarding AuthenticationOk message to client")
          pg_send(client_sock, [auth_msg], :server) { |str| cnputs.(script_to_client(str)) }

        else
          # request cleartext password from client
          pg_send(client_sock, [pg_msg("R", "\x00\x00\x00\x03")], :server) { |str| cnputs.(script_to_client(str)) }
          pwd_msg = client_reader.next_message(true) { |str| cnputs.(client_to_script(str)) }
          early_exit.("for client to request password") if pwd_msg.nil?
          raise "expected password message" unless pwd_msg[0] == "p"
          pwd = pwd_msg[5..].unpack1("Z*") # remove null terminator

          # silently re-parse the auth message so as to keep track of the auth protocol stage we're at with the server
          PgMessage.new(auth_msg, :server).inspect

          case auth_type
          when 3 # AuthenticationCleartextPassword -> forward the client's message on
            pg_send(server_sock, [pwd_msg], :client) { |str| cnputs.(script_to_server(str)) }

          when 5 # AuthenticationMD5
            salt = auth_msg[9..]
            md5 = Digest::MD5.hexdigest(Digest::MD5.hexdigest(pwd + username) + salt)
            pg_send(server_sock, [pg_msg("p", "md5#{md5}\x00")], :client) { |str| cnputs.(script_to_server(str)) }

          when 10 # AuthenticationSASL
            unless has_sasl
              cnputs.("SCRAM auth was requested by server but is not supported on this version of Ruby: exiting")
              exit 1
            end
            authenticators = { # highest preference first
              **(options[:channel_binding] != 'disable' ? {"SCRAM-SHA-256-PLUS" => ScramSHA256PlusAuthenticator} : {}),
              **(options[:channel_binding] != 'require' ? {"SCRAM-SHA-256" => ScramSHA256Authenticator} : {}),
            }
            offered_mechanisms = auth_msg[9..].split("\x00")
            mechanism = (authenticators.keys & offered_mechanisms).first
            raise "no supported SASL mechanism: support #{authenticators.keys.inspect}, offered #{offered_mechanisms.inspect}" if mechanism.nil?

            auth = authenticators[mechanism].new(username: "*", password: pwd, ssl_cert: options[:channel_binding] == 'disable' ? nil : server_sock.peer_cert)
            client_initial_msg = auth.process(nil)
            scram_msg = bin_str("#{mechanism}\x00#{[client_initial_msg.length].pack("N")}#{client_initial_msg}")
            pg_send(server_sock, [pg_msg("p", scram_msg)], :client) { |str| cnputs.(script_to_server(str)) }

            server_first_msg = server_reader.next_message { |str| cnputs.(server_to_script(str)) }
            early_exit.("awaiting AuthenticationSASLContinue") if server_first_msg.nil?
            raise "expected AuthenticationSASLContinue" unless server_first_msg[0] == "R" && server_first_msg[5..8] == bin_str("\x00\x00\x00\x0b")

            client_final_msg = auth.process(server_first_msg[9..])
            pg_send(server_sock, [pg_msg("p", client_final_msg)], :client) { |str| cnputs.(script_to_server(str)) }

            server_final_message = server_reader.next_message { |str| cnputs.(server_to_script(str)) }
            early_exit.("awaiting AuthenticationSASLFinal") if server_final_message.nil?
            raise "expected AuthenticationSASLFinal" unless server_final_message[0] == "R" && server_final_message[5..8] == bin_str("\x00\x00\x00\x0c")

            auth.process(server_final_message[9..]) # raises an error if server is not authenticated

          else
            raise "unsupported server auth type with code: #{auth_type}"
          end
        end
      end

      # proxy ongoing traffic

      log_proxied = options[:log_proxied] != "none"
      cnputs.("#{log_proxied ? "" : "silently "}forwarding all later traffic")

      exit_queue = Queue.new

      # pass messages from server to client
      server_to_client_thread = Thread.new do
        while true do
          messages = server_reader.available_messages { |str| cnputs.(server_to_client(str)) if log_proxied }
          if messages.nil?
            cnputs.("server hung up")
            exit_queue.push(:server_eof)
            break
          end
          bytes_sent = pg_send(client_sock, messages)
          bytes_left = server_reader.buffer.length
          cnputs.(colour(Colour::LEN, "^^ #{bytes_sent} bytes forwarded #{BYTE_WRITE ? 'one by one ' : ''}at +#{(t_now - t0).floor(2)}s#{bytes_left > 0 ? ", #{bytes_left} bytes left in buffer" : ""}")) if log_proxied
        end
      end

      # pass messages from client to server
      client_to_server_thread = Thread.new do
        while true do
          messages = client_reader.available_messages { |str| cnputs.(client_to_server(str)) if log_proxied }
          if messages.nil?
            cnputs.("client hung up")
            exit_queue.push(:client_eof)
            break
          end
          bytes_sent = pg_send(server_sock, messages)
          bytes_left = client_reader.buffer.length
          cnputs.(colour(Colour::LEN, "^^ #{bytes_sent} bytes forwarded #{BYTE_WRITE ? 'one by one ' : ''}at +#{(t_now - t0).floor(2)}s#{bytes_left > 0 ? ", #{bytes_left} bytes left in buffer" : ""}")) if log_proxied
        end
      end

      #Â block until either client or server hangs up
      exit_queue.pop

    ensure
      cnputs.("connection end")
      client_to_server_thread.kill unless client_to_server_thread.nil?
      server_to_client_thread.kill unless server_to_client_thread.nil?
      client_sock.close unless client_sock.nil?
      server_sock.close unless server_sock.nil?
    end
  end

  if options[:quit_on_hangup]
    conn_thread.join
    exit
  end
end
